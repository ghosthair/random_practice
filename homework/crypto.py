"""
COMP4722: Network Security
Implement the following functions using the Python secrets and cryptography libraries.
The input and output variables, and expected types are given as comments in each function.

The implementation should thoroughly check for any errors/exceptions that may be generated
during runtime. The functions should never raise an exception of any type other than the
CryptoException class defined below. This way we can ensure that we have considered the
different types of errors/exceptions that can arise in the implementation. Errors can be
malformed input errors, incorrect key sizes, etc. and exceptiopipns can be ones created by your
implementation and also from the used libraries.

All random numbers used in your implementation should be generated using your implemented
generate_random_securely() function

**** NEED TODO ****
 - Double check that the params are taken in as their comments, do I need to change them to bytes, or do I 
expect bytes?
 - Add exception class


"""
import os
import secrets as sc
import cryptography as cy
from cryptography.hazmat.primitives import constant_time as ct
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.primitives.asymmetric import rsa, ec, padding
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.exceptions import InvalidSignature
import hashlib

class CryptoException(Exception):
    '''
    Custom exception class
    The below functions should raise exceptions of this class when any error is encountered.
    The code from this file should never raise an exception of any other class.
    Example usage:
        try:
            ...
        except TypeError:
            raise CryptoException("Data value must be in bytes")
    '''
    pass


################# BEGIN TODO

def generate_random_securely(size=None):
    '''
    Generate random bytes using Python secrets library

    :param size: number of bytes required (integer)
    :return: randomly generated bytes (byte string)

    **** COMPLETED ****
    '''
    print("Randomly Secure Function")
    x = sc.token_bytes(size)
    return x 


def hash_message(data, hash_method):
    '''
    Perform hash on data

    :param data: the data to hash (byte string)
    :param hash_method: the hash function to use -- one of "SHA256" or "SHA512" (string)
    :return: hash of the data (byte string)
    
    **** COMPLETED ****
    '''
    x = hash_method.upper()
    if x == "SHA256":
        m = hashlib.sha256()
    elif x == "SHA512":
        m = hashlib.sha512()
    else:
        # raise CryptoException
        print("Not a valid hash choice")
        
    m.update(data)
    return m.digest()


def hmac_message(data, hash_method, key):
    '''
    Compute HMAC of data

    :param data: the data to HMAC (byte string)
    :param hash_method: the hash function to use -- one of "SHA256" or "SHA512" (string)
    :param key: the key to use in HMAC (byte string)
    :return: HMAC of the data (byte string)

    **** NOT COMPLETED ****

    '''
    hmac = data + key

    x = hash_method.upper()
    if x == "SHA256":
        m = hashlib.sha256()
    elif x == "SHA512":
        m = hashlib.sha512()
    else:
        # raise CryptoException
        print("Not a valid hash choice")

    m.update(hmac)
    return m.digest()


def verify_hash(data, hash_method, mac):
    '''
    Verify that a given hash is correct for some data

    :param data: the data on which the hash is supposedly computed (byte string)
    :param hash_method: the hash method supposedly used -- one of "SHA256" or "SHA512" (string)
    :param mac: the hash value to match against (byte string)
    :return: True if a match; otherwise False

    Note: when performing comparisons, use constant time functions,
          e.g. constant_time.bytes_eq in cryptography library

    **** NOT COMPLETED ****
    Need to review with the professor or the TA, all I did was re-hash it.

    '''

    #This is just selecting the hash method, need to research method to compare.
    x = hash_method.upper()
    if x == "SHA256":
        m = hashlib.sha256()
    elif x == "SHA512":
        m = hashlib.sha512()
    else:
        # raise CryptoException
        print("Not a valid hash choice")
    x = hash_message(mac, "sha256")

    m.update(data)
    y = m.digest()

    a = ct.bytes_eq(x, y)
    return a


def verify_hmac(data, hash_method, key, mac):
    '''
    Verify that a given HMAC is correct for some data

    :param data: the data on which the HMAC is supposedly computed (byte string)
    :param hash_method: the hash method supposedly used -- one of "SHA256" or "SHA512" (string)
    :param key: the key supposedly used in HMAC (byte string)
    :param mac: the hash value to match against (byte string)
    :return: True if a match; otherwise False
    
    
    Reading through docs use hmac.compare(a,b) instead of ==

    **** NOT COMPLETED ****
    Need to review with the professor or the TA, all I did was re-hash it.

    '''
    hmac = data + key
    x = hash_method.upper()
    if x == "SHA256":
        m = hashlib.sha256()
    elif x == "SHA512":
        m = hashlib.sha512()
    else:
        # raise CryptoException
        print("Not a valid hash choice")

    m.update(hmac)
    j = m.digest()

    y = hmac_message(mac, hash_method, key)
    a = ct.bytes_eq(j,y)
    return a


def sym_encrypt(data, sym_key, algo, chain_mode, mac_key=None, mac_mode=None):
    '''
    Perform symmetric encryption on some data, along with optional MAC

    :param data: the data to encrypt (byte string)
    :param sym_key: the symmetric secret key (byte string)
    :param algo: the encryption algorithm - one of "AES128" or "ChaCha20" (string)
    :param chain_mode: the chaining mode to use - one of "CBC", "CTR" or "GCM" (string)
    :param mac_key: the key to use when computing MAC (byte string)
    :param mac_mode: the method to compute the MAC - one of "ETM" (encrypt-then-MAC),
                     "EAM" (encrypt-and-MAC) or "MTE" (MAC-then-encrypt) (string or None)
    :return: a three tuple (iv, ct, mac) - each a byte string
             iv: an initial value used in the encryption (e.g. an initialization vector, or a nonce)
             ct: the ciphertext
             mac: the computed MAC or None

    Note: If AES128-GCM is used, ignore mac_mode and return the tag produced by GCM as MAC
          For other cases, no MAC is computed if mac_mode is None

    **** TODO ****
    Complete the AES-GCM mode
    Swap out the key with sym_key
    Add the elif line if mac is none to just complete the encryption.
    '''
    #Dictionaries to call the algorithim and chain mode
    alo_map = {"AES128":algorithms.AES128, "CHACHA20":algorithms.ChaCha20}
    modes_map = {"CBC":modes.CBC, "CTR":modes.CTR, "GCM":modes.GCM}
    # key = os.urandom(16) # Need to replace with sym_key
    #Taking the key from the input, also need to add error handling here if the key is wrong size.
    key = sym_key
    iv = os.urandom(16)

    # Padding for the data to make sure it is the appropriate block size
    pad = padding.PKCS7(128).padder()
    padded_data = pad.update(data) + pad.finalize()

    cipher_text = Cipher(alo_map[algo.upper()](key), modes_map[chain_mode.upper()](iv))
    encryptor = cipher_text.encryptor()
    enc_text = encryptor.update(padded_data) + encryptor.finalize()
    mac = hmac_message(data, "SHA256", mac_key)

    #Calling the AES-CGM mode.
    if algo.upper() == "AES128" and chain_mode.upper() == "GCM":
        print("AES GCM mode")
        mac_mode = None
        mac_key = None
        aes_gcm_key = AESGCM.generate_key(128)
        aes_gcm = AESGCM(aes_gcm_key)
        aes_gcm_nonce = os.urandom(12)
        aes_gcm_ct = aes_gcm.encrypt(aes_gcm_nonce, data, None)
        mac = aes_gcm_ct[-16:]
        final_enc = aes_gcm_ct
    #Checking if it is ETM mode
    elif mac_mode.upper() == "ETM":
        print("ETM")
        mac = hmac_message(enc_text, "SHA256", mac_key)
        final_enc = enc_text
    #Checking for Encrypt and Mac mode
    elif mac_mode.upper() == "EAM":
        print("EAM")
        combined = enc_text + mac
        if chain_mode.upper() in ["CBC"]:
            padder = padding.PKCS7(128).padder()
            combined = padder.update(combined) + padder.finalize()
        encryptor = cipher_text.encryptor()
        final_enc = encryptor.update(combined) + encryptor.finalize()
    #Checking for MTE mode
    elif mac_mode.upper() == "MTE":
        print("MTE")
        mte_data = data + mac
        if chain_mode.upper() in ["CBC"]:
            padder = padding.PKCS7(128).padder()
            mte_data = padder.update(mte_data) + padder.finalize()
        encryptor = cipher_text.encryptor()
        final_enc = encryptor.update(mte_data) + encryptor.finalize()
    #Part of the error handling for this.
    else:
        final_enc = cipher_text
        print("So close try again!")
    
    final_product = (iv, final_enc, mac)
    return final_product


def sym_decrypt(data, sym_key, iv, algo, chain_mode, mac_key=None, mac=None, mac_mode=None):
    '''
    Perform symmetric decryption on some data, along with MAC verification

    :param data: the data to decrypt (byte string)
    :param sym_key: the symmetric secret key (byte string)
    :param iv: initial value used during encryption (byte string)
    :param algo: the decryption algorithm - one of "AES128" or "ChaCha20" (string)
    :param chain_mode: the chaining mode to use - one of "CBC", "CTR" or "GCM" (string)
    :param mac_key: the key to use when verifying the MAC (byte string)
    :param mac: the MAC against which the MAC verification is to be done (byte string)
    :param mac_mode: the method used to compute the MAC - one of "ETM" (encrypt-then-MAC),
                     "EAM" (encrypt-and-MAC) or "MTE" (MAC-then-encrypt) (string or None)
    :return: plain text (byte string)

    Note: If AES128-GCM is used, ignore mac_mode and verify mac against the one expected by GCM
          For other cases, no MAC verification is done if mac_mode is None
          The function should raise a CryptoException if MAC verification is done, but is found to be invalid
    '''
    alo_map = {"AES128":algorithms.AES128, "CHACHA20":algorithms.ChaCha20}
    modes_map = {"CBC":modes.CBC, "CTR":modes.CTR, "GCM":modes.GCM}

    cipher_text = Cipher(alo_map[algo.upper()](sym_key), modes_map[chain_mode.upper()](iv))
    decryptor = cipher_text.decryptor()
    padded_text = decryptor.update(data) + decryptor.finalize()

    if chain_mode.upper() == "CBC":
        unpadder = padding.PKCS7(128).unpadder()
        plain_text = unpadder.update(padded_text) + unpadder.finalize()

    return plain_text


def gen_rsa_keypair(size):
    '''
    Generate a RSA public and private keypair

    :param size: key size (integer)
    :return: a tuple (pu, pr) - each a RSAPrivateKey instance of cryptography library
             pu: public key
             pr: private key

    **** COMPLETED ****

    '''
    private_key = rsa.generate_private_key(65537, size)
    public_key = private_key.public_key()

    key = (public_key, private_key)
    return key


def gen_ec_keypair():
    '''
    Generate a P-256 elliptic curve public and private keypair

    :return: a tuple (pu, pr) - each an EllipticCurvePrivateKey instance of cryptography library
             pu: public key
             pr: private key

    **** COMPLETED ****
             
    '''
    private_key = ec.generate_private_key(ec.SECP256R1())
    pub_key = private_key.public_key()
    keys = (pub_key, private_key)

    return keys


def save_public_key(public_key, file):
    '''
    Serialize and saves a RSAPublicKey or EllipticCurvePublicKey instance as a PEM file

    :param public_key: the public key (RSAPublicKey or EllipticCurvePublicKey)
    :param file: output file name (use .pem extension) (string)
    
    COMPLETED
    
    '''
    pem_pub = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    )
    pem_pub.splitlines()[0]
    with open(file, "wb") as f:
        f.write(pem_pub)
    return pem_pub


def save_private_key(private_key, file, password=None):
    '''
    Serialize and saves a RSAPrivateKey or EllipticCurvePrivateKey instance as a PEM file

    :param private_key: the private key (RSAPrivateKey or EllipticCurvePrivateKey)
    :param password: optional password to encrypt saved file (byte string)
    :param file: output file name (use .pem extension) (string)
    
    **** COMPLETED ****
    
    '''
    pw = password
    if pw is not None:
        pem = private_key.private_bytes(
            encoding=serialization.Encoding.PEM, 
            format=serialization.PrivateFormat.TraditionalOpenSSL, 
            encryption_algorithm=serialization.BestAvailableEncryption(pw))
        pem.splitlines()[0]
    else:
        pem = private_key.private_bytes(
            encoding=serialization.Encoding.PEM, 
            format=serialization.PrivateFormat.TraditionalOpenSSL, 
            encryption_algorithm=serialization.NoEncryption())
        pem.splitlines()[0]
    with open(file, "wb") as f:
        f.write(pem)
    return pem


def load_public_key(file):
    '''
    Load a RSAPublicKey or EllipticCurvePublicKey from a PEM file

    :param file: input file name (string)
    :return: the public key (RSAPublicKey or EllipticCurvePublicKey)
    
    **** COMPLETED ****
    
    '''
    with open(file, "rb") as f:
        pem_pub = f.read()
    pub_key = serialization.load_pem_public_key(pem_pub)
    print(pub_key)
    return pub_key


def load_private_key(file, password=None):
    '''
    Load a RSAPrivateKey or EllipticCurvePrivateKey from a PEM file

    :param file: input file name (string)
    :param password: optional password to decrypt input file, if it was saved with encryption (byte string)
    :return: the private key (RSAPrivateKey or EllipticCurvePrivateKey)
    
    **** COMPLETED ****
    
    '''
    with open(file, "rb") as f:
        pem_pri = f.read()
    pri_key = serialization.load_pem_private_key(pem_pri, password)
    print(pri_key)
    return


def rsa_encrypt(data, public_key):
    '''
    Encrypt some data using RSA

    :param data: data to encrypt (byte string)
    :param public_key: public key to use (RSAPublicKey)
    :return: ciphertext (byte string)

    Note: The amount of data you can encrypt will be limited. Experiment!
    '''
    ciphertext = public_key.encrypt(
        data,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )
    return ciphertext


def rsa_decrypt(data, private_key):
    '''
    Decrypt some data using RSA

    :param data: data to decrypt (byte string)
    :param private_key: private key to use (RSAPrivateKey)
    :return: plaintext (byte string)
    '''
    plain_text = private_key.decrypt(
        data, 
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )
    return plain_text


def rsa_envelope_encrypt(data, public_key):
    '''
    Envelope encrypt some data using RSA and AES128-GCM

    :param data: data to encrypt (byte string)
    :param public_key: public key to use (RSAPublicKey)
    :return: a four tuple (key_ct, iv, ct, mac) - each a byte string
             key_ct: ciphertext of symmetric key
             iv: initial value used in symmetric encryption
             ct: ciphertext of data
             mac: GCM computed MAC on data

    Note: Although not necessary here, key_ct can be provided as "additional authentication data" to
          GCM so that we can have integrity protection on key_ct as well
    '''
    key = os.urandom(16)
    aesgcm = AESGCM(key)
    nonce = os.urandom(12)
    ciphertext_and_mac = aesgcm.encrypt(nonce, data, None)

    ciphertext = ciphertext_and_mac[:-16]
    mac = ciphertext_and_mac[-16:]

    key_ct = public_key.encrypt(
        key,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )

    return key_ct, nonce, ciphertext, mac


def rsa_envelope_decrypt(data, key_data, iv, mac, private_key):
    '''
    Decrypt some data envelope encrypted using RSA and AES128-GCM

    :param data: data to decrypt (byte string)
    :param key_data: encrypted symmetric key (byte string)
    :param iv: initial value used in symmetric encryption (byte string)
    :param mac: MAC on data to compare against
    :param private_key: private key to use (RSAPrivateKey)
    :return: plaintext (byte string)

    Note: The function should raise a CryptoException if the MAC is invalid
    '''
    try:
        aes_key = private_key.decrypt(
            key_data, # I think this is the syemtical key
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        cipher_and_mac = data + mac

        aesgcm = AESGCM(aes_key)
        plaintext = aesgcm.decrypt(iv, cipher_and_mac, None)
        return plaintext
    except Exception as e:
        raise CryptoException("CryptoException: MAC verfications failed or decryption error.") from e


def generate_signature(data, method, private_key):
    '''
    Sign some data using RSA/ECDSA with SHA256

    :param data: data to sign (byte string)
    :param method: signing method - one of "RSA" or "ECDSA" (string)
    :param private_key: private key to use for signing (RSAPrivateKey or EllipticCurvePrivateKey)
    :return: signature (byte string)
    '''
    method = method.upper()

    if method not in ["RSA", "ECDSA"]:
        raise CryptoException("Imporper method picked for verification, please pick RSA or ECDSA")

    if method == "RSA":
        signature = private_key.sign(
            data,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
    elif method == "ECDSA":
        signature = private_key.sign(
            data,
            ec.ECDSA(hashes.SHA256())
        )

    return signature


def verify_signature(data, method, public_key, signature):
    '''
    Verify a RSA/ECDSA with SHA256 signature on some data

    :param data: data on which signature is generated (byte string)
    :param method: signing method - one of "RSA" or "ECDSA" (string)
    :param public_key: public key to use for verification (RSAPublicKey or EllipticCurvePublicKey)
    :param signature: the signature to verify against (byte string)
    :return: True if signature is valid; otherwise False
    '''
    method = method.upper()

    if method not in ["RSA", "ECDSA"]:
        raise CryptoException("Imporper method picked for verification, please pick RSA or ECDSA")
    try:
        if method == "RSA":
            public_key.verify(
                signature,
                data,
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
        elif method == "ECDSA":
            public_key.verify(signature, data, ec.ECDSA(hashes.SHA256()))
        else:
            print("No proper method picked")
        return True
    except InvalidSignature:
        return False
    except Exception as e:
        raise CryptoException("Signature verifcation failed, not false but the process failed.")

################# END TODO


def print_ba(b, prefix=''):
    '''
    Print byte string as hex string in the format:
         [prefix] <hex string> (<bit length of input>)

    :param b: byte string (byte string)
    :param prefix: prefix to be printed before the hex string (string)
    '''
    print(prefix, end="")
    if b is not None:
        print('0x' + ''.join(format(x, '02x') for x in b), end="")
        print(' (' + str(len(b) * 8) + ' bits)')
    else:
        print('None')


if __name__ == "__main__":
    # Write your test code here
	# print(generate_random_securely(15))
	# print("This is the hash message\n", hash_message(b"Hellow World","sHa256"))
    # print("This is hmac message\n", hmac_message(b"Hello World", "SHA256", b"SuperSecret"))
    # print("This is verify hash: True or False.\n", verify_hash(b"Hello World", "sha256", b"Hello World"))
    # print("This is verify hmac\n", verify_hmac(b"Hello World", "sha256", b"SuperSecret", b"Hello World"))
    # print(sym_encrypt(b"Hello World", b'\x83\xf1\x7b\xc9\x14\x2e\xba\xdf\x90\x65\x7c\xee\x19\xa3\x28\xcb', "AES128", "CBC", b"MACKEY!", "ETM"))
    # print(sym_decrypt(b'\xe9\x97\x18\xad\xbfJO\xa3\xf9\xb6;\x16\xa5MP\xf8', b'\x83\xf1\x7b\xc9\x14\x2e\xba\xdf\x90\x65\x7c\xee\x19\xa3\x28\xcb', b'\xd2\xd9Yf\xabF\xbb%[y\xca\xd6/\xcf_ ', "AES128", "CBC", b"MACKEY!", b'\x91\x18\xf4\xba\xcfc\xc7*\x0e\xf2\xa4\xd2\xd2_{\xecH@\xa7\x87\xd4)\xc6\xe9{\xb2\xe5O\x10\xe9lU', "ETM"))
    rsa_key = gen_rsa_keypair(2048)
    rsa_pub = rsa_key[0]
    rsa_pri = rsa_key[1]
    ec_key = gen_ec_keypair()
    ec_pub = ec_key[0]
    ec_pri = ec_key[1]
    # print(ec_key)
    # print(save_public_key(ec_key[0], "public_key.pem"))
    # print(save_private_key(ec_key[1], "private_key.pem", b"password123"))
    # load_public_key("public_key.pem")
    # load_private_key("private_key.pem", b"password123")
    # rsa_ciphertext = rsa_encrypt(b"Hello World", rsa_pub)
    # print(rsa_decrypt(rsa_ciphertext, rsa_pri))
    # print(rsa_envelope_encrypt(b"Hello World", rsa_pub))
    # key_data, env_iv, cipher_text, env_mac = rsa_envelope_encrypt(b"Hello World", rsa_pub)
    # print(f"Key Data: {key_data}\nIV{env_iv}\nCipher Text{cipher_text}\nMAC{env_mac}")
    # print(rsa_envelope_decrypt(cipher_text, key_data, env_iv, env_mac, rsa_pri))
    signature = generate_signature(b"Hello World", "ECDSA", ec_pri)
    # print(signature)
    print(verify_signature(b"Hello World", "ECDSA", ec_pub, signature))